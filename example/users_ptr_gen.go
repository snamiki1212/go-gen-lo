// Code generated by "go-gen-lo"; DO NOT EDIT.
// Based on information from https://github.com/snamiki1212/go-gen-lo

package main

import "github.com/samber/lo"

// Filter
func (xs UserPtrs) Filter(predicate func(item *User, index int) bool) UserPtrs {
	return lo.Filter(xs, predicate)
}

// Map
func (xs UserPtrs) Map(iteratee func(item *User, index int) *User) UserPtrs {
	return lo.Map(xs, iteratee)
}

// FilterUserID
func (xs UserPtrs) FilterUserID(field string) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.UserID == field
	})
}

// FilterInt
func (xs UserPtrs) FilterInt(field int) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.Int == field
	})
}

// FilterIntPtr
func (xs UserPtrs) FilterIntPtr(field *int) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.IntPtr == field
	})
}

// FilterBool
func (xs UserPtrs) FilterBool(field bool) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.Bool == field
	})
}

// FilterBoolPtr
func (xs UserPtrs) FilterBoolPtr(field *bool) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.BoolPtr == field
	})
}

// FilterStr
func (xs UserPtrs) FilterStr(field string) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.Str == field
	})
}

// FilterStrPtr
func (xs UserPtrs) FilterStrPtr(field *string) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.StrPtr == field
	})
}

// FilterStruct0
func (xs UserPtrs) FilterStruct0(field DefinedStruct0) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.Struct0 == field
	})
}

// FilterStructPtr0
func (xs UserPtrs) FilterStructPtr0(field *DefinedStruct0) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.StructPtr0 == field
	})
}

// FilterStruct1
func (xs UserPtrs) FilterStruct1(field DefinedStruct1) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.Struct1 == field
	})
}

// FilterStructPtr1
func (xs UserPtrs) FilterStructPtr1(field *DefinedStruct1) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.StructPtr1 == field
	})
}

// FilterChanSend0
func (xs UserPtrs) FilterChanSend0(field chan<- int) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.ChanSend0 == field
	})
}

// FilterChanSendPtr0
func (xs UserPtrs) FilterChanSendPtr0(field *chan<- int) UserPtrs {
	return lo.Filter(xs, func(entity *User, index int) bool {
		return entity.ChanSendPtr0 == field
	})
}

// KeyByUserID
func (xs UserPtrs) KeyByUserID() map[string]*User {
	return lo.KeyBy(xs, func(entity *User) string {
		return entity.UserID
	})
}

// KeyByInt
func (xs UserPtrs) KeyByInt() map[int]*User {
	return lo.KeyBy(xs, func(entity *User) int {
		return entity.Int
	})
}

// KeyByIntPtr
func (xs UserPtrs) KeyByIntPtr() map[*int]*User {
	return lo.KeyBy(xs, func(entity *User) *int {
		return entity.IntPtr
	})
}

// KeyByBool
func (xs UserPtrs) KeyByBool() map[bool]*User {
	return lo.KeyBy(xs, func(entity *User) bool {
		return entity.Bool
	})
}

// KeyByBoolPtr
func (xs UserPtrs) KeyByBoolPtr() map[*bool]*User {
	return lo.KeyBy(xs, func(entity *User) *bool {
		return entity.BoolPtr
	})
}

// KeyByStr
func (xs UserPtrs) KeyByStr() map[string]*User {
	return lo.KeyBy(xs, func(entity *User) string {
		return entity.Str
	})
}

// KeyByStrPtr
func (xs UserPtrs) KeyByStrPtr() map[*string]*User {
	return lo.KeyBy(xs, func(entity *User) *string {
		return entity.StrPtr
	})
}

// KeyByStruct0
func (xs UserPtrs) KeyByStruct0() map[DefinedStruct0]*User {
	return lo.KeyBy(xs, func(entity *User) DefinedStruct0 {
		return entity.Struct0
	})
}

// KeyByStructPtr0
func (xs UserPtrs) KeyByStructPtr0() map[*DefinedStruct0]*User {
	return lo.KeyBy(xs, func(entity *User) *DefinedStruct0 {
		return entity.StructPtr0
	})
}

// KeyByStruct1
func (xs UserPtrs) KeyByStruct1() map[DefinedStruct1]*User {
	return lo.KeyBy(xs, func(entity *User) DefinedStruct1 {
		return entity.Struct1
	})
}

// KeyByStructPtr1
func (xs UserPtrs) KeyByStructPtr1() map[*DefinedStruct1]*User {
	return lo.KeyBy(xs, func(entity *User) *DefinedStruct1 {
		return entity.StructPtr1
	})
}

// KeyByChanSend0
func (xs UserPtrs) KeyByChanSend0() map[chan<- int]*User {
	return lo.KeyBy(xs, func(entity *User) chan<- int {
		return entity.ChanSend0
	})
}

// KeyByChanSendPtr0
func (xs UserPtrs) KeyByChanSendPtr0() map[*chan<- int]*User {
	return lo.KeyBy(xs, func(entity *User) *chan<- int {
		return entity.ChanSendPtr0
	})
}
