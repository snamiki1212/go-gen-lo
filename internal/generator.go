package internal

import (
	"bytes"
	"fmt"
	"text/template"
)

type loMethods string

const (
	loMethodsFilter loMethods = "Filter"
	loMethodsMap    loMethods = "Map"
)

var loMethodsAll = []loMethods{loMethodsFilter, loMethodsMap}

var templates = map[loMethods]string{
	loMethodsFilter: `
// Filter
func (xs {{ .Slice }}) Filter(predicate func(item {{ .Entity }}, index int) bool) {{ .Slice }} {
	return lo.Filter(xs, predicate)
}
`,
	loMethodsMap: `
// Map
func (xs {{ .Slice }}) Map(iteratee func(item {{ .Entity }}, index int) {{ .Entity }}) {{ .Slice }} {
	return lo.Map(xs, iteratee)
}
`,
}

// const templFilter = `
// // Filter
// func (xs {{ .Slice }}) Filter(predicate func(item {{ .Entity }}, index int) bool) {{ .Slice }} {
// 	return lo.Filter(xs, predicate)
// }
// `

// const templMap = `
// // Map
// func (xs {{ .Slice }}) Map(iteratee func(item {{ .Entity }}, index int) {{ .Entity }}) {{ .Slice }} {
// 	return lo.Map(xs, iteratee)
// }
// `

const templExtendFilter = `
// FilterBy{{ .Field }}
func (xs {{ .Slice }}) FilterBy{{ .Field }}({{ .Field }} {{ .Type }}) {{ .Slice }} {
	return lo.Filter(xs, func(item {{ .Entity }}, index int) bool {
		return item.{{ .Field }} == {{ .Field }}
	})
}
`

// Replace variable from key to value in template.
type templateMapper struct {
	Slice  string // Slice name for target struct (ex. Users).
	Entity string // Entity name for target struct (ex. User / *User).
	Type   string // Type name of field (ex. string).
	Field  string // Field name of struct (ex. UserID).
}

// Generate code
func Generate(args arguments, data data) (string, error) {
	pkgName := data.pkgName
	sliceName := data.sliceName
	infos := data.fields

	if len(infos) == 0 {
		return "", nil
	}

	var txt string

	// append header
	txt += "// Code generated by go generate DO NOT EDIT.\n\n"
	txt += "package " + pkgName + "\n\n"
	txt += `import "github.com/samber/lo"` + "\n\n"

	{
		// append templates
		var doc bytes.Buffer

		for _, method := range loMethodsAll {
			// Get Template src
			rawTp, ok := templates[method]
			if !ok {
				return "", fmt.Errorf("template not found: %s", method)
			}

			// New Template
			tp, err := template.New("").Parse(rawTp)
			if err != nil {
				return "", fmt.Errorf("template parse error: %w", err)
			}

			// Generate txt from template
			data := &templateMapper{Slice: sliceName, Entity: args.DisplayEntity()}
			if err = tp.Execute(&doc, data); err != nil {
				return "", fmt.Errorf("template execute error: %w", err)
			}
		}
		txt += doc.String()
	}

	// append filter by
	{
		var doc bytes.Buffer
		tp, err := template.New("").Parse(templExtendFilter)
		if err != nil {
			return "", fmt.Errorf("template parse error: %w", err)
		}
		for _, info := range infos {
			data := &templateMapper{
				Slice:  sliceName,
				Entity: args.DisplayEntity(),
				Type:   info.Type,
				Field:  info.Name,
			}

			err = tp.Execute(&doc, data)
			if err != nil {
				return "", fmt.Errorf("template execute error: %w", err)
			}
		}
		txt += doc.String()
	}

	return txt, nil
}

type tt struct{}

func (t tt) Template() string {
	return `
	// FilterBy{{ .Field }}
func (xs {{ .Slice }}) FilterBy{{ .Field }}({{ .Field }} {{ .Type }}) {{ .Slice }} {
	return lo.Filter(xs, func(item {{ .Entity }}, index int) bool {
		return item.{{ .Field }} == {{ .Field }}
	})
}
	`
}
